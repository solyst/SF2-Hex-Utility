using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SF2_Hex_Utility
{
    public partial class EditFieldDetails : UserControl
    {
        static public bool AlwaysGenerateContextFromRom { get; set; } = false; //if TRUE, don't use the context from the Hex Location and instead generate it from the selected Unused Rom

        public bool ShowToolTips { get { return toolTip1.Active; } set { toolTip1.Active = value; } }


        private EditField editField;
        public EditField EditField
        {
            get { return editField; }
            set
            {
                //unsubscribe always, if it's not null 
                if (editField != null)
                    editField.HexLocationChanged -= editField_HexLocationChanged;

                //assign value 
                editField = value;

                //subscribe again, if it's not null
                if (editField != null)
                    editField.HexLocationChanged += editField_HexLocationChanged;
            }
        }


        public Rom UnchangedRom { get; set; }

        public EditFieldDetails()
        {
            InitializeComponent();
            updateDetails();
        }



        //------------------------------------------------------------------
        // Event Summary
        //------------------------------------------------------------------
        #region Event_Summary
        /// <raises>
        ///     None
        /// </raises>
        /// <listens>
        ///     editField.HexLocationChanged = will update the visual and fields to reflect the context of the Hex Location
        /// </listens>
        #endregion



        //------------------------------------------------------------------
        // Methods
        //------------------------------------------------------------------
        #region Methods

        private void editField_HexLocationChanged(object sender, EventArgs e)
        {
            updateDetails();
        }

        
        public void UpdateDetails(EditField editField)
        {
            this.EditField = editField;
            updateDetails();
        }


        private void updateDetails()
        {
            if (EditField == null)
            {
                this.Hide();
            }
            else
            {
                //locationDuplicate only used when the RefType is WildcardMatch
                string locationString = HexRenderer.IntToHexString(EditField.HexLocation.GetEditLocation(EditField.Rom, out bool locationDuplicate), 4);
                if (locationDuplicate)
                {
                    lblLocation.Text = locationString + " (dup)";
                    lblLocation.ForeColor = Color.Red;
                }
                else
                {
                    lblLocation.Text = locationString;
                    lblLocation.ForeColor = SystemColors.WindowText;
                }

                lblName.Text = EditField.HexLocation.Name;
                lblRefType.Text = EditField.HexLocation.RefType.ToString();
                lblLength.Text = EditField.HexLocation.Length.ToString();
                lblFormat.Text = EditField.HexLocation.Format.ToString();
                //lblValue.Text = HexRenderer.BytesToHexString(EditField.Value, false);
                //lblOriginalValue.Text = HexRenderer.BytesToHexString(EditField.HexLocation.Bytes, false);
                lblValue.Text = EditField.HexLocation.ToString(EditField.Value); 
                lblOriginalValue.Text = EditField.HexLocation.ToString(EditField.HexLocation.Bytes);
                txtDescription.Text = EditField.HexLocation.Description;

                picHex.Refresh();
                picRom.Refresh();
                this.Show();
            }
        }


        //This handles whether to show the context from the HexLocation or automatically generate it from the Unchanged Rom.
        private void picHex_Paint(object sender, PaintEventArgs e)
        {
            if (this.Visible)
            {
                if (EditField != null && EditField.HexLocation.Context.Length > 1 && AlwaysGenerateContextFromRom == false)
                {
                    byte[] context = EditField.HexLocation.Context;
                    int byteOffsetInContext = EditField.HexLocation.ByteOffsetInContext;
                    int contextLocation = EditField.HexLocation.GetContextLocation(null);
                    drawContext(e, context, byteOffsetInContext, contextLocation);
                    lblContextAutoGenerated.Visible = false;
                }
                else if (EditField != null && UnchangedRom != null)
                {
                    int contextLocation;
                    byte[] context = EditField.HexLocation.FindContextFromRom(UnchangedRom, out contextLocation);
                    int byteOffsetInContext = EditField.HexLocation.GetEditLocation(UnchangedRom) - contextLocation;
                    drawContext(e, context, byteOffsetInContext, contextLocation);
                    lblContextAutoGenerated.Visible = true;
                }
                else
                {
                    lblContextAutoGenerated.Visible = false;
                }
            }
        }


        private void drawContext(PaintEventArgs e, byte[] context, int byteOffsetInContext, int contextLocation)
        {
            if (this.Visible)
            {
                Point offsetPoint = new Point(5, 22);
                Point headerPoint = new Point(5 + 60, 5);
                Point hexPoint = new Point(5 + 60, 22);

                HexRenderer.DrawHexHeader(e.Graphics, headerPoint);
                int firstByteOffset = HexRenderer.FindFirstByteOffset(contextLocation);
                HexRenderer.DrawHexWithHighlight(e.Graphics, context, true, firstByteOffset, byteOffsetInContext, EditField.HexLocation.Bytes.Length, hexPoint);
                int dataLocationToShow = contextLocation - firstByteOffset;
                int rows = (context.Length + firstByteOffset) / HexRenderer.BytesPerLine + 1;
                HexRenderer.DrawHexOffsets(e.Graphics, dataLocationToShow, rows, offsetPoint);
            }
        }


        private void picRom_Paint(object sender, PaintEventArgs e)
        {
            if (EditField != null)
            {
                Point offsetPoint = new Point(5, 22);
                Point headerPoint = new Point(5 + 60, 5);
                Point hexPoint = new Point(5 + 60, 22);

                HexRenderer.DrawHexHeader(e.Graphics, headerPoint);
                int editLocation = EditField.HexLocation.GetEditLocation(EditField.Rom);
                int firstByteOffset = HexRenderer.FindFirstByteOffset(editLocation);
                int dataLocationToShow = editLocation - firstByteOffset - HexRenderer.BytesPerLine;
                int rows = (EditField.HexLocation.Length / HexRenderer.BytesPerLine + 3);
                int dataLengthToShow = rows * HexRenderer.BytesPerLine;
                byte[] romData = EditField.Rom.GetData(dataLocationToShow, dataLengthToShow);
                HexRenderer.DrawHexWithHighlight(e.Graphics, romData, true, 0, firstByteOffset + HexRenderer.BytesPerLine, EditField.HexLocation.Length, hexPoint);
                HexRenderer.DrawHexOffsets(e.Graphics, dataLocationToShow, rows, offsetPoint);
            }
        }

        #endregion



    }
}
